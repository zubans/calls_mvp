<!DOCTYPE html>
<html>
<head>
    <title>WebRTC Video Call Client</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        .video-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin: 20px 0;
        }
        video {
            width: 300px;
            height: 200px;
            background-color: #000;
            border: 1px solid #ccc;
        }
        .controls {
            margin: 20px 0;
        }
        button {
            padding: 10px 15px;
            margin: 5px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        input {
            padding: 8px;
            margin: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .log {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 10px;
            height: 200px;
            overflow-y: scroll;
            font-family: monospace;
            font-size: 12px;
        }
        .auth-section {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        .error {
            color: red;
            font-weight: bold;
        }
        .success {
            color: green;
            font-weight: bold;
        }
        .warning {
            color: orange;
            font-weight: bold;
        }
        .info {
            color: blue;
            font-weight: bold;
        }
        .permission-prompt {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
            text-align: center;
        }
    </style>
</head>
<body>
    <h1>WebRTC Video Call Client</h1>
    
    <div id="permissionPrompt" class="permission-prompt">
        <h3>Camera and Microphone Access Required</h3>
        <p>Please allow access to your camera and microphone to use this video call client.</p>
        <button id="requestPermissionsBtn">Grant Camera/Microphone Access</button>
        <div id="permissionStatus"></div>
    </div>
    
    <div id="mainContent" style="display: none;">
        <div class="auth-section">
            <h3>Authentication</h3>
            <div>
                <input type="text" id="usernameInput" placeholder="Username" value="user1">
                <input type="password" id="passwordInput" placeholder="Password" value="password123">
            </div>
            <div>
                <button id="loginBtn">Login</button>
                <button id="registerBtn">Register</button>
            </div>
            <div style="margin-top: 10px;">
                <input type="text" id="tokenInput" placeholder="Access Token">
                <button id="useTokenBtn">Use Token</button>
            </div>
            <div id="authStatus"></div>
        </div>
        
        <div class="controls">
            <input type="text" id="roomInput" placeholder="Room ID" value="test-room">
            <button id="joinBtn" disabled>Join Room</button>
            <button id="leaveBtn" disabled>Leave Room</button>
        </div>
        
        <div class="video-container">
            <div>
                <h3>Local Video</h3>
                <video id="localVideo" autoplay muted></video>
            </div>
            <div>
                <h3>Remote Video</h3>
                <video id="remoteVideo" autoplay></video>
            </div>
        </div>
        
        <div class="controls">
            <button id="startCallBtn" disabled>Start Call</button>
            <button id="endCallBtn" disabled>End Call</button>
        </div>
    </div>
    
    <h3>Logs</h3>
    <div id="log" class="log"></div>

    <script>
        // DOM elements
        const permissionPrompt = document.getElementById('permissionPrompt');
        const mainContent = document.getElementById('mainContent');
        const requestPermissionsBtn = document.getElementById('requestPermissionsBtn');
        const permissionStatus = document.getElementById('permissionStatus');
        
        const usernameInput = document.getElementById('usernameInput');
        const passwordInput = document.getElementById('passwordInput');
        const loginBtn = document.getElementById('loginBtn');
        const registerBtn = document.getElementById('registerBtn');
        const tokenInput = document.getElementById('tokenInput');
        const useTokenBtn = document.getElementById('useTokenBtn');
        const authStatus = document.getElementById('authStatus');
        
        const roomInput = document.getElementById('roomInput');
        const joinBtn = document.getElementById('joinBtn');
        const leaveBtn = document.getElementById('leaveBtn');
        const startCallBtn = document.getElementById('startCallBtn');
        const endCallBtn = document.getElementById('endCallBtn');
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const logDiv = document.getElementById('log');
        
        // State variables
        let localStream = null;
        let remoteStream = null;
        let peerConnection = null;
        let roomId = null;
        let clientId = null;
        let accessToken = null;
        let permissionsGranted = false;
        let ws = null;
        let remoteCandidatesQueue = [];
        let isInitiator = false;
        
        // Configuration
        const SERVER_URL = 'http://localhost:8181';
        const ICE_SERVERS = [
            { urls: 'stun:stun.l.google.com:19302' }
        ];
        
        // WebRTC configuration
        const RTC_CONFIG = {
            iceServers: ICE_SERVERS
        };
        
        // Log function
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.textContent = `[${timestamp}] ${message}`;
            
            if (type === 'error') {
                logEntry.className = 'error';
            } else if (type === 'success') {
                logEntry.className = 'success';
            } else if (type === 'warning') {
                logEntry.className = 'warning';
            } else if (type === 'info') {
                logEntry.className = 'info';
            }
            
            logDiv.appendChild(logEntry);
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(`[${type.toUpperCase()}] ${message}`);
        }
        
        // Update permission status
        function updatePermissionStatus(message, type = 'info') {
            permissionStatus.textContent = message;
            permissionStatus.className = type;
        }
        
        // Update auth status
        function updateAuthStatus(message, type = 'info') {
            authStatus.textContent = message;
            authStatus.className = type;
        }
        
        // Request media permissions immediately
        async function requestMediaPermissions() {
            try {
                updatePermissionStatus('Requesting camera and microphone access...', 'info');
                log('Requesting camera and microphone access...');
                
                // Request permissions with constraints
                const constraints = {
                    video: {
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        facingMode: 'user'
                    },
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true
                    }
                };
                
                localStream = await navigator.mediaDevices.getUserMedia(constraints);
                
                // Display local video
                localVideo.srcObject = localStream;
                
                // Show which devices are being used
                const videoTracks = localStream.getVideoTracks();
                const audioTracks = localStream.getAudioTracks();
                
                if (videoTracks.length > 0) {
                    log(`Camera access granted: ${videoTracks[0].label || 'Default camera'}`, 'success');
                }
                
                if (audioTracks.length > 0) {
                    log(`Microphone access granted: ${audioTracks[0].label || 'Default microphone'}`, 'success');
                }
                
                updatePermissionStatus('Camera and microphone access granted!', 'success');
                permissionsGranted = true;
                
                // Hide permission prompt and show main content
                permissionPrompt.style.display = 'none';
                mainContent.style.display = 'block';
                
                log('Ready to use video call client!', 'success');
                
            } catch (error) {
                log(`Permission error: ${error.name} - ${error.message}`, 'error');
                
                // Provide specific error messages
                switch (error.name) {
                    case 'NotAllowedError':
                        updatePermissionStatus('Permission denied. Click "Grant Camera/Microphone Access" and allow permissions.', 'error');
                        log('Permission denied. Please allow access to camera and microphone.', 'error');
                        log('Click the camera/microphone icon in the browser address bar to grant permissions.', 'warning');
                        break;
                    case 'NotFoundError':
                        updatePermissionStatus('No camera or microphone found.', 'error');
                        log('No camera or microphone found. Please check your hardware.', 'error');
                        break;
                    case 'NotReadableError':
                        updatePermissionStatus('Camera or microphone is being used by another application.', 'error');
                        log('Camera or microphone is being used by another application.', 'error');
                        break;
                    case 'OverconstrainedError':
                        updatePermissionStatus('Camera constraints cannot be satisfied. Trying basic constraints...', 'warning');
                        log('Camera constraints cannot be satisfied. Trying with basic constraints...', 'warning');
                        // Try with basic constraints
                        try {
                            localStream = await navigator.mediaDevices.getUserMedia({video: true, audio: true});
                            localVideo.srcObject = localStream;
                            updatePermissionStatus('Camera and microphone access granted with basic constraints!', 'success');
                            permissionsGranted = true;
                            permissionPrompt.style.display = 'none';
                            mainContent.style.display = 'block';
                            log('Got media stream with basic constraints!', 'success');
                            return;
                        } catch (fallbackError) {
                            updatePermissionStatus(`Fallback also failed: ${fallbackError.message}`, 'error');
                            log(`Fallback also failed: ${fallbackError.message}`, 'error');
                        }
                        break;
                    default:
                        updatePermissionStatus(`Unknown error: ${error.message}`, 'error');
                        log('Unknown error occurred while accessing media devices.', 'error');
                }
                
                log('Troubleshooting tips:', 'warning');
                log('1. Check browser address bar for camera/microphone permission icons', 'warning');
                log('2. Ensure no other application is using the camera/microphone', 'warning');
                log('3. Check browser settings for camera/microphone permissions', 'warning');
                log('4. Try refreshing the page after granting permissions', 'warning');
            }
        }
        
        // Register user
        async function registerUser() {
            const username = usernameInput.value;
            const password = passwordInput.value;
            
            if (!username || !password) {
                updateAuthStatus('Please enter username and password', 'error');
                return;
            }
            
            try {
                log('Registering user...');
                const response = await fetch(`${SERVER_URL}/register`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        username: username,
                        email: `${username}@example.com`,
                        password: password
                    })
                });
                
                const data = await response.json();
                
                if (!response.ok) {
                    throw new Error(data.error || 'Registration failed');
                }
                
                log(`User registered successfully`, 'success');
                updateAuthStatus('User registered. Now login.', 'success');
                
            } catch (error) {
                log(`Error registering user: ${error.message}`, 'error');
                updateAuthStatus(`Error: ${error.message}`, 'error');
            }
        }
        
        // Login user
        async function loginUser() {
            const username = usernameInput.value;
            const password = passwordInput.value;
            
            if (!username || !password) {
                updateAuthStatus('Please enter username and password', 'error');
                return;
            }
            
            try {
                log('Logging in...');
                const response = await fetch(`${SERVER_URL}/login`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        identifier: username,
                        password: password
                    })
                });
                
                const data = await response.json();
                
                if (!response.ok) {
                    throw new Error(data.error || 'Login failed');
                }
                
                accessToken = data.token;
                tokenInput.value = accessToken;
                joinBtn.disabled = false;
                
                log('Login successful', 'success');
                updateAuthStatus('Login successful', 'success');
                
            } catch (error) {
                log(`Error logging in: ${error.message}`, 'error');
                updateAuthStatus(`Error: ${error.message}`, 'error');
            }
        }
        
        // Use token from input
        function useToken() {
            accessToken = tokenInput.value.trim();
            if (accessToken) {
                joinBtn.disabled = false;
                log('Token set manually', 'success');
                updateAuthStatus('Token set', 'success');
            } else {
                joinBtn.disabled = true;
                log('Token cleared', 'info');
                updateAuthStatus('Token cleared', 'info');
            }
        }
        
        // Join room
        async function joinRoom() {
            roomId = roomInput.value;
            
            if (!roomId) {
                log('Please enter room ID', 'error');
                return;
            }
            
            if (!accessToken) {
                log('Please login first to get access token', 'error');
                return;
            }
            
            if (!permissionsGranted) {
                log('Please grant camera and microphone permissions first', 'error');
                return;
            }
            
            try {
                log('Joining room...');
                const response = await fetch(`${SERVER_URL}/join-room`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `${accessToken}`
                    },
                    body: JSON.stringify({
                        room_id: roomId
                    })
                });
                
                const data = await response.json();
                
                if (!response.ok) {
                    throw new Error(data.error || 'Failed to join room');
                }
                
                clientId = data.client_id;
                
                log(`Joined room successfully`, 'success');
                
                // Update UI
                joinBtn.disabled = true;
                leaveBtn.disabled = false;
                startCallBtn.disabled = false;

                // Connect WebSocket for signaling
                connectSignaling();
                
            } catch (error) {
                log(`Error joining room: ${error.message}`, 'error');
            }
        }
        
        // Leave room
        async function leaveRoom() {
            if (!roomId || !clientId) {
                log('Not in a room', 'error');
                return;
            }
            
            try {
                log('Leaving room...');
                const response = await fetch(`${SERVER_URL}/leave-room`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `${accessToken}`
                    },
                    body: JSON.stringify({
                        room_id: roomId,
                        client_id: clientId
                    })
                });
                
                if (!response.ok) {
                    const data = await response.json();
                    log(`Warning: ${data.error || 'Failed to leave room'}`, 'error');
                }
                
                // Clean up local resources
                cleanup();
                
                // Update UI
                joinBtn.disabled = false;
                leaveBtn.disabled = true;
                startCallBtn.disabled = true;
                endCallBtn.disabled = true;
                
                log('Left room', 'success');
                
            } catch (error) {
                log(`Error leaving room: ${error.message}`, 'error');
                // Still clean up local resources even if server request fails
                cleanup();
            }
        }
        
        // Clean up resources
        function cleanup() {
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            
            // Note: We don't stop the local stream here since we requested it at startup
            // and want to keep it available for future use
            
            remoteVideo.srcObject = null;
            
            clientId = null;
            isInitiator = false;
            remoteCandidatesQueue = [];
            if (ws) {
                try { ws.close(); } catch (_) {}
                ws = null;
            }
        }
        
        // Start call
        async function startCall() {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                log('Signaling connection not ready', 'error');
                return;
            }
            if (!localStream) {
                log('No local media stream', 'error');
                return;
            }

            ensurePeerConnection();

            try {
                isInitiator = true;
                const offer = await peerConnection.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true });
                await peerConnection.setLocalDescription(offer);
                sendSignal({
                    type: 'offer',
                    room_id: roomId,
                    sender_id: clientId,
                    sdp: offer
                });
                log('Sent SDP offer', 'info');
                startCallBtn.disabled = true;
                endCallBtn.disabled = false;
            } catch (err) {
                log(`Failed to start call: ${err.message}`, 'error');
            }
        }
        
        // End call
        function endCall() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                sendSignal({ type: 'end-call', room_id: roomId, sender_id: clientId });
            }
            cleanup();
            log('Call ended', 'success');
            startCallBtn.disabled = false;
            endCallBtn.disabled = true;
        }

        function connectSignaling() {
            const wsURL = `${SERVER_URL.replace('http', 'ws')}/ws?token=${encodeURIComponent(accessToken)}`;
            ws = new WebSocket(wsURL);

            ws.onopen = () => {
                log('Signaling connected', 'success');
                sendSignal({ type: 'join', room_id: roomId, sender_id: clientId });
            };

            ws.onmessage = async (event) => {
                try {
                    const message = parseMaybeConcatenated(event.data);
                    for (const m of message) {
                        await handleSignalMessage(m);
                    }
                } catch (e) {
                    log(`WS message error: ${e.message}`, 'error');
                }
            };

            ws.onclose = () => {
                log('Signaling disconnected', 'warning');
            };

            ws.onerror = (e) => {
                log('Signaling error', 'error');
            };
        }

        function sendSignal(obj) {
            if (!ws || ws.readyState !== WebSocket.OPEN) return;
            try {
                ws.send(JSON.stringify(obj));
            } catch (e) {
                log(`Failed to send signal: ${e.message}`, 'error');
            }
        }

        function ensurePeerConnection() {
            if (peerConnection) return;
            peerConnection = new RTCPeerConnection(RTC_CONFIG);

            // Add local tracks
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });

            // ICE candidates
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    sendSignal({
                        type: 'ice-candidate',
                        room_id: roomId,
                        sender_id: clientId,
                        candidate: event.candidate
                    });
                }
            };

            // Remote track handling
            peerConnection.ontrack = (event) => {
                if (!remoteStream) {
                    remoteStream = new MediaStream();
                }
                event.streams[0]?.getTracks().forEach(t => remoteStream.addTrack(t));
                remoteVideo.srcObject = remoteStream;
                startCallBtn.disabled = true;
                endCallBtn.disabled = false;
            };

            // If remote candidates were received before remote description
            peerConnection.oniceconnectionstatechange = () => {
                log(`ICE state: ${peerConnection.iceConnectionState}`, 'info');
            };
        }

        async function handleSignalMessage(msg) {
            // Ignore messages from self or other rooms
            if (msg.room_id !== roomId || msg.sender_id === clientId) return;

            switch (msg.type) {
                case 'join': {
                    log('Peer joined room', 'info');
                    // Optionally enable start button for callee
                    startCallBtn.disabled = false;
                    break;
                }
                case 'offer': {
                    ensurePeerConnection();
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(msg.sdp));
                    // Drain queued ICE if any
                    await drainRemoteIceQueue();
                    const answer = await peerConnection.createAnswer();
                    await peerConnection.setLocalDescription(answer);
                    sendSignal({
                        type: 'answer',
                        room_id: roomId,
                        sender_id: clientId,
                        sdp: answer
                    });
                    log('Received offer and sent answer', 'success');
                    break;
                }
                case 'answer': {
                    if (!peerConnection) return;
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(msg.sdp));
                    await drainRemoteIceQueue();
                    log('Received answer', 'success');
                    break;
                }
                case 'ice-candidate': {
                    const candidate = new RTCIceCandidate(msg.candidate);
                    if (peerConnection && peerConnection.remoteDescription) {
                        try { await peerConnection.addIceCandidate(candidate); } catch (e) { log(`ICE add failed: ${e.message}`, 'error'); }
                    } else {
                        remoteCandidatesQueue.push(candidate);
                    }
                    break;
                }
                case 'end-call': {
                    log('Peer ended the call', 'warning');
                    cleanup();
                    startCallBtn.disabled = false;
                    endCallBtn.disabled = true;
                    break;
                }
                default:
                    break;
            }
        }

        async function drainRemoteIceQueue() {
            if (!peerConnection || !peerConnection.remoteDescription) return;
            while (remoteCandidatesQueue.length) {
                const c = remoteCandidatesQueue.shift();
                try { await peerConnection.addIceCandidate(c); } catch (e) { log(`ICE add failed: ${e.message}`, 'error'); }
            }
        }

        function parseMaybeConcatenated(data) {
            // Our WS server may concatenate messages with spaces; split when possible
            try {
                const obj = JSON.parse(data);
                return [obj];
            } catch (_) {
                // Try split by space and parse individually
                const parts = String(data).split(' ').filter(Boolean);
                const out = [];
                for (const p of parts) {
                    try { out.push(JSON.parse(p)); } catch (_) {}
                }
                return out.length ? out : [];
            }
        }
        
        // Event listeners
        requestPermissionsBtn.addEventListener('click', requestMediaPermissions);
        registerBtn.addEventListener('click', registerUser);
        loginBtn.addEventListener('click', loginUser);
        useTokenBtn.addEventListener('click', useToken);
        joinBtn.addEventListener('click', joinRoom);
        leaveBtn.addEventListener('click', leaveRoom);
        startCallBtn.addEventListener('click', startCall);
        endCallBtn.addEventListener('click', endCall);
        
        // Initialize - request permissions immediately
        document.addEventListener('DOMContentLoaded', function() {
            log('Client initialized. Requesting camera and microphone permissions...');
            requestMediaPermissions();
        });
    </script>
</body>
</html>